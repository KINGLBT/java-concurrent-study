# 何去何从的并行计算

## 可怕的现实：摩尔定律的失效

摩尔定律内容：集成电路上可容纳的电晶体数目，每隔24个月会增加一倍，预计24个月会将芯片的性能
提高一倍（即更多的晶体管使其更快）。

但是，摩尔定律并不是一种自然法则或者物理定律，它只是基于人为观测数据对未来的预测。按照这种速度，
我们的计算能力将会按照指数速度增长。

然而，在2004年，Intel宣布彻底取消4GHz计划。是什么迫使Intel科技巨头放弃4GHz的研发呢？

显然，就目前的硅电路，似乎已经走到尽头了。制造工艺已经精确到纳米了，如果无法在物质分子层面下
进行工作，4GHz的芯片已经接近理论极限了。

因此，摩尔定律在CPU的计算性能上可能已经失效了。

## CPU计算能力还需要不断前进

摩尔定律失效后，不在追求单核的计算能力，开始将多个独立的计算单元整合到一个CPU上，也就是我们所说的
多核CPU。

## 光明或黑暗

多个独立的计算单元整合到一个CPU上，随之而来的是并行计算的到来，程序员的黑暗时刻真正到来，程序的复杂度
也跟着成倍增加。
所以，如何让多个CPU有效并且正确的工作成为了一门新的技术。


# 必须知道的几个概念

## 同步（Synchronous）和异步（Asynchronous）

同步方法调用一旦开始，调用者必须等待，知道返回结果，才能继续后续的行为。
异步方法调用一旦开始，会立即放回结果，调用者可以继续后续的才做。而异步方法通常会
在另一个线城中执行。

![Image text](https://raw.githubusercontent.com/KINGLBT/java-concurrent-study/master/image/chapter1/1-1.png)

## 并发（Concurrency）和并行（Parallelism）

都可以表示为两个或者多个任务，一起执行。侧重点不同，并发偏重于多个任务交替执行，而多个任务还可能是串行的。
并行是真正意义上的同时执行。

实际情况中，如果一个系统只有一个CPU，而使用多线程执行任务，这些任务不可能是真实并行的，毕竟一个CPU一次只能执行一条指令。

真实的并行，只可能出现在多个CPU系统中，如多核CPU

![Image text](https://raw.githubusercontent.com/KINGLBT/java-concurrent-study/master/image/chapter1/1-2.png)

## 临界区

临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程资源想要
使用这个资源，必须等待。

在并行程序中，临界资源是用来保护的对象。

## 阻塞（Blocking）和非阻塞（Non-Blocking）

阻塞和非阻塞通常用来形容多线程间的互相影响。
比如，一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中等待。等待会导致线程挂起，这种情况就是阻塞。

## 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）
死锁、饥饿和活锁都属于多线程的活跃性问题。如果发现上述几种情况，那么相关线程可能就不再活跃，也就是说很难再继续往下执行。

死锁：线程间彼此相互占用了其他线程的资源，都在彼此等待对方释放，那么这种状态将持续下去，谁都不可能得到临界资源。
饥饿：是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。例如它的线程优先级可能太低，而高优先级的线程不断
抢占它需要的资源。导致低优先级线程无法工作。
活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

# 并发级别

